
name: Tests

on:
  push:
    branches: '**' #all branches
    tags: 'v*.*.*' #all version tags
  pull_request: #all pull requests

jobs:
  build-test:
    runs-on: ubuntu-latest
    env:
      image: ldmx/dev:latest #define image to rbuild ldmx-sw and run tests on
    defaults:
      run:
        shell: bash

    steps:
    # check out ldmx-sw in the workspace
    - uses: actions/checkout@v2
    - uses: textbook/git-checkout-submodule-action@master

    # Setup our ldmx development environment
    - name: Setup ldmx environment
      run: docker pull $image
    
    # configure ldmx-sw using the docker environment
    - name: Configure the build
      run: |
          mkdir build &&
          docker run -i -v $(pwd):$(pwd) $image $(pwd)/build cmake ..

    # build ldmx-sw using the docker environment
    - name: Build and Install
      run: docker run -i -v $(pwd):$(pwd) $image $(pwd)/build make install

    # Run the test using ctest. The --verbose parameter displays the output 
    # you would typically see with catch.
    - name: Test the build
      run: |
          cd ../ &&
          export LDMX_BASE=$(pwd) &&
          docker run -i -e LDMX_BASE -v $(pwd):$(pwd) $image $LDMX_BASE/ldmx-sw/build ctest --verbose 

    # The rest of the steps are building docs
    #   Since the build is made and tested above,
    #   the docs are only updated if the build passes
    # They need to be in the same job as the build becuase
    #   the sphinx-apidoc command needs the python package
    #   structured like a normal python package. 

    # Runs doxygen doxygen.conf in the docs/ directory
    - name: Run Doxygen to build C++ Docs
      uses: mattnotmitt/doxygen-action@v1.1.0
      with:
        doxyfile-path: doxygen.conf/doxyfile #relative to working directory
        working-directory: docs #docs subdirectory

    # sphinx is a python package, so we need to setup python on this runner
    - name: Setup Python for Sphinx
      uses: actions/setup-python@v2
      with:
        python-version: 3.6
    
    # Runs sphinx-apidoc and sphinx-build in the docs/ directory
    #   sphinx-apidoc requires the python files to be packaged together
    #   like a python module would be. The simplest way to achieve
    #   this form is to build and install ldmx-sw.
    - name: Run Sphinx to build python Docs
      run: |
          python3 -m pip install -U pip
          python3 -m pip install Sphinx Pillow groundwork-sphinx-theme
          sphinx-apidoc --force --no-toc -o docs/sphinx.conf/ install/python
          sudo `which sphinx-build` docs/sphinx.conf docs/html/_sphinx

    # Check if we should deploy the docs
    #   Only deploy if the github ref matchs the default branch of the repository
    #   This only happens if we are pushing a commit to the default branch
    - name: Check if we should deploy the Docs
      id: check_deploy
      run: |
        _we_should="no"
        if [[ "$GITHUB_REF" == "refs/heads/${{ github.event.repository.default_branch }}" ]];
        then
          _we_should="yes"
        fi
        echo "Should we deploy the docs? ${_we_should}"
        echo ::set-output name=we_should_deploy_docs::${_we_should}


    # Copy the generated documentation to the github pages repo
    #   This copies all the html files in the docs/html directory to the github.io repository
    #   using the ldmx organization token for access and saving the changes with the
    #   commit message of the commit that activated this action
    - name: Deploy the Docs
      if: ${{ steps.check_deploy.outputs.we_should_deploy_docs == 'yes' }}
      uses: peaceiris/actions-gh-pages@v3
      with:
        personal_token: ${{ secrets.LDMX_ORG_TOKEN }} #requires setup to connect ldmx-sw and ldmx-sw.github.io
        commit_message: ${{ github.event.head_commit.message }}
        external_repository: LDMX-Software/ldmx-software.github.io
        publish_branch: trunk 
        publish_dir: ./docs/html
        enable_jekyll: true #allow github pages to process using jekyll
        keep_files: true #keep old files (by default, clears publish_dir before deploying to it)

  generate-image:
    if: ${{ github.event_name == 'push' }} #only generate production image if pushing a commit
    needs: build-test #will only generate production image if build-test finishes successfully
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
    -
      name: Setup QEMU
      uses: docker/setup-qemu-action@v1
    -
      name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1
    -
      name: Login to DockerHub
      uses: docker/login-action@v1
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    - 
      name: Get Build Context
      uses: actions/checkout@v2
    -
      name: Determine Image Tags
      id: generate_tag
      run: |
        _tags=""
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          # if pushing a git tag ==> get the git tag for the docker tag
          _git_tag=${GITHUB_REF#refs/tags/}
          _tags="ldmx/pro:$_git_tag"
          if [[ $_git_tag =~ ^v[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            # there was a version released on github
            #   v<1-3 digits>.<1-3 digits>.<1-3 digits>
            _tags="$_tags,ldmx/pro:latest"
          fi
        elif [[ $GITHUB_REF == refs/heads/* ]]; then
          # pushing to a branch, repo may change
          _branch=$(echo ${GITHUB_REF#refs/heads/} | sed -r 's#/+#-#g')
          if [ "${{ github.event.repository.default_branch }}" = "$_branch" ]; then
            #on default branch, set repository to mainline repo and set tag to edge
            _repo="ldmx/pro"
          elif [ -f .github/workflows/production_image_repo ]; then
            #not default branch and production image repo is defined
            _repo=$(cat .github/workflows/production_image_repo)
            if [ "$_repo" = "ldmx/pro" ]; then
              echo "Can't push a non-master branch commit to 'ldmx/pro'. Create your own repository."
              exit 2
            fi
          else
            #not default branch without production image defined
            _repo=UNDEFINED
          fi
          _tags="$_repo:edge,$_repo:sha-${GITHUB_SHA::8}"
        else
          echo "Running Determine Image Tags on a commit that isn't a tag or a branch."
          exit 1
        fi
        echo "Generated Tags: ${_tags}"
        echo ::set-output name=tags::${_tags}
    -
      name: Build the Image
      id: docker_build
      uses: docker/build-push-action@v2
      with:
        tags: ${{ steps.generate_tag.outputs.push_tags }}
        push: contains(steps.generate_tag.outputs.tags,"/")

